# coding: utf-8

"""
    weather.gov API

    weather.gov API

    The version of the OpenAPI document: 1.13.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from pynwsdata.models.alert_certainty import AlertCertainty
from pynwsdata.models.alert_geocode import AlertGeocode
from pynwsdata.models.alert_message_type import AlertMessageType
from pynwsdata.models.alert_references_inner import AlertReferencesInner
from pynwsdata.models.alert_severity import AlertSeverity
from pynwsdata.models.alert_status import AlertStatus
from pynwsdata.models.alert_urgency import AlertUrgency
from typing import Optional, Set
from typing_extensions import Self

class Alert(BaseModel):
    """
    An object representing a public alert message. Unless otherwise noted, the fields in this object correspond to the National Weather Service CAP v1.2 specification, which extends the OASIS Common Alerting Protocol (CAP) v1.2 specification and USA Integrated Public Alert and Warning System (IPAWS) Profile v1.0. Refer to this documentation for more complete information. http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html http://docs.oasis-open.org/emergency/cap/v1.2/ipaws-profile/v1.0/cs01/cap-v1.2-ipaws-profile-cs01.html https://alerts.weather.gov/#technical-notes-v12 
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="The identifier of the alert message.")
    area_desc: Optional[StrictStr] = Field(default=None, description="A textual description of the area affected by the alert.", alias="areaDesc")
    geocode: Optional[AlertGeocode] = None
    affected_zones: Optional[List[StrictStr]] = Field(default=None, description="An array of API links for zones affected by the alert. This is an API-specific extension field and is not part of the CAP specification. ", alias="affectedZones")
    references: Optional[List[AlertReferencesInner]] = Field(default=None, description="A list of prior alerts that this alert updates or replaces.")
    sent: Optional[datetime] = Field(default=None, description="The time of the origination of the alert message.")
    effective: Optional[datetime] = Field(default=None, description="The effective time of the information of the alert message.")
    onset: Optional[datetime] = Field(default=None, description="The expected time of the beginning of the subject event of the alert message.")
    expires: Optional[datetime] = Field(default=None, description="The expiry time of the information of the alert message.")
    ends: Optional[datetime] = Field(default=None, description="The expected end time of the subject event of the alert message.")
    status: Optional[AlertStatus] = None
    message_type: Optional[AlertMessageType] = Field(default=None, alias="messageType")
    category: Optional[StrictStr] = Field(default=None, description="The code denoting the category of the subject event of the alert message.")
    severity: Optional[AlertSeverity] = None
    certainty: Optional[AlertCertainty] = None
    urgency: Optional[AlertUrgency] = None
    event: Optional[StrictStr] = Field(default=None, description="The text denoting the type of the subject event of the alert message.")
    sender: Optional[StrictStr] = Field(default=None, description="Email address of the NWS webmaster.")
    sender_name: Optional[StrictStr] = Field(default=None, description="The text naming the originator of the alert message.", alias="senderName")
    headline: Optional[StrictStr] = Field(default=None, description="The text headline of the alert message.")
    description: Optional[StrictStr] = Field(default=None, description="The text describing the subject event of the alert message.")
    instruction: Optional[StrictStr] = Field(default=None, description="The text describing the recommended action to be taken by recipients of the alert message. ")
    response: Optional[StrictStr] = Field(default=None, description="The code denoting the type of action recommended for the target audience. This corresponds to responseType in the CAP specification. ")
    parameters: Optional[Dict[str, List[Any]]] = Field(default=None, description="System-specific additional parameters associated with the alert message. The keys in this object correspond to parameter definitions in the NWS CAP specification. ")
    __properties: ClassVar[List[str]] = ["id", "areaDesc", "geocode", "affectedZones", "references", "sent", "effective", "onset", "expires", "ends", "status", "messageType", "category", "severity", "certainty", "urgency", "event", "sender", "senderName", "headline", "description", "instruction", "response", "parameters"]

    @field_validator('category')
    def category_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Met', 'Geo', 'Safety', 'Security', 'Rescue', 'Fire', 'Health', 'Env', 'Transport', 'Infra', 'CBRNE', 'Other']):
            raise ValueError("must be one of enum values ('Met', 'Geo', 'Safety', 'Security', 'Rescue', 'Fire', 'Health', 'Env', 'Transport', 'Infra', 'CBRNE', 'Other')")
        return value

    @field_validator('response')
    def response_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Shelter', 'Evacuate', 'Prepare', 'Execute', 'Avoid', 'Monitor', 'Assess', 'AllClear', 'None']):
            raise ValueError("must be one of enum values ('Shelter', 'Evacuate', 'Prepare', 'Execute', 'Avoid', 'Monitor', 'Assess', 'AllClear', 'None')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Alert from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of geocode
        if self.geocode:
            _dict['geocode'] = self.geocode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in references (list)
        _items = []
        if self.references:
            for _item in self.references:
                if _item:
                    _items.append(_item.to_dict())
            _dict['references'] = _items
        # set to None if onset (nullable) is None
        # and model_fields_set contains the field
        if self.onset is None and "onset" in self.model_fields_set:
            _dict['onset'] = None

        # set to None if ends (nullable) is None
        # and model_fields_set contains the field
        if self.ends is None and "ends" in self.model_fields_set:
            _dict['ends'] = None

        # set to None if headline (nullable) is None
        # and model_fields_set contains the field
        if self.headline is None and "headline" in self.model_fields_set:
            _dict['headline'] = None

        # set to None if instruction (nullable) is None
        # and model_fields_set contains the field
        if self.instruction is None and "instruction" in self.model_fields_set:
            _dict['instruction'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Alert from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "areaDesc": obj.get("areaDesc"),
            "geocode": AlertGeocode.from_dict(obj["geocode"]) if obj.get("geocode") is not None else None,
            "affectedZones": obj.get("affectedZones"),
            "references": [AlertReferencesInner.from_dict(_item) for _item in obj["references"]] if obj.get("references") is not None else None,
            "sent": obj.get("sent"),
            "effective": obj.get("effective"),
            "onset": obj.get("onset"),
            "expires": obj.get("expires"),
            "ends": obj.get("ends"),
            "status": obj.get("status"),
            "messageType": obj.get("messageType"),
            "category": obj.get("category"),
            "severity": obj.get("severity"),
            "certainty": obj.get("certainty"),
            "urgency": obj.get("urgency"),
            "event": obj.get("event"),
            "sender": obj.get("sender"),
            "senderName": obj.get("senderName"),
            "headline": obj.get("headline"),
            "description": obj.get("description"),
            "instruction": obj.get("instruction"),
            "response": obj.get("response"),
            "parameters": obj.get("parameters")
        })
        return _obj


