# coding: utf-8

"""
    weather.gov API

    weather.gov API

    The version of the OpenAPI document: 1.13.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from pynwsdata.models.json_ld_context import JsonLdContext
from pynwsdata.models.metar_phenomenon import MetarPhenomenon
from pynwsdata.models.observation_cloud_layers_inner import ObservationCloudLayersInner
from pynwsdata.models.quantitative_value import QuantitativeValue
from typing import Optional, Set
from typing_extensions import Self

class Observation(BaseModel):
    """
    Observation
    """ # noqa: E501
    context: Optional[JsonLdContext] = Field(default=None, alias="@context")
    geometry: Optional[StrictStr] = Field(default=None, description="A geometry represented in Well-Known Text (WKT) format.")
    id: Optional[StrictStr] = Field(default=None, alias="@id")
    type: Optional[StrictStr] = Field(default=None, alias="@type")
    elevation: Optional[QuantitativeValue] = None
    station: Optional[StrictStr] = None
    timestamp: Optional[datetime] = None
    raw_message: Optional[StrictStr] = Field(default=None, alias="rawMessage")
    text_description: Optional[StrictStr] = Field(default=None, alias="textDescription")
    icon: Optional[StrictStr] = None
    present_weather: Optional[List[MetarPhenomenon]] = Field(default=None, alias="presentWeather")
    temperature: Optional[QuantitativeValue] = None
    dewpoint: Optional[QuantitativeValue] = None
    wind_direction: Optional[QuantitativeValue] = Field(default=None, alias="windDirection")
    wind_speed: Optional[QuantitativeValue] = Field(default=None, alias="windSpeed")
    wind_gust: Optional[QuantitativeValue] = Field(default=None, alias="windGust")
    barometric_pressure: Optional[QuantitativeValue] = Field(default=None, alias="barometricPressure")
    sea_level_pressure: Optional[QuantitativeValue] = Field(default=None, alias="seaLevelPressure")
    visibility: Optional[QuantitativeValue] = None
    max_temperature_last24_hours: Optional[QuantitativeValue] = Field(default=None, alias="maxTemperatureLast24Hours")
    min_temperature_last24_hours: Optional[QuantitativeValue] = Field(default=None, alias="minTemperatureLast24Hours")
    precipitation_last_hour: Optional[QuantitativeValue] = Field(default=None, alias="precipitationLastHour")
    precipitation_last3_hours: Optional[QuantitativeValue] = Field(default=None, alias="precipitationLast3Hours")
    precipitation_last6_hours: Optional[QuantitativeValue] = Field(default=None, alias="precipitationLast6Hours")
    relative_humidity: Optional[QuantitativeValue] = Field(default=None, alias="relativeHumidity")
    wind_chill: Optional[QuantitativeValue] = Field(default=None, alias="windChill")
    heat_index: Optional[QuantitativeValue] = Field(default=None, alias="heatIndex")
    cloud_layers: Optional[List[ObservationCloudLayersInner]] = Field(default=None, alias="cloudLayers")
    __properties: ClassVar[List[str]] = ["@context", "geometry", "@id", "@type", "elevation", "station", "timestamp", "rawMessage", "textDescription", "icon", "presentWeather", "temperature", "dewpoint", "windDirection", "windSpeed", "windGust", "barometricPressure", "seaLevelPressure", "visibility", "maxTemperatureLast24Hours", "minTemperatureLast24Hours", "precipitationLastHour", "precipitationLast3Hours", "precipitationLast6Hours", "relativeHumidity", "windChill", "heatIndex", "cloudLayers"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['wx:ObservationStation']):
            raise ValueError("must be one of enum values ('wx:ObservationStation')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Observation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of context
        if self.context:
            _dict['@context'] = self.context.to_dict()
        # override the default output from pydantic by calling `to_dict()` of elevation
        if self.elevation:
            _dict['elevation'] = self.elevation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in present_weather (list)
        _items = []
        if self.present_weather:
            for _item in self.present_weather:
                if _item:
                    _items.append(_item.to_dict())
            _dict['presentWeather'] = _items
        # override the default output from pydantic by calling `to_dict()` of temperature
        if self.temperature:
            _dict['temperature'] = self.temperature.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dewpoint
        if self.dewpoint:
            _dict['dewpoint'] = self.dewpoint.to_dict()
        # override the default output from pydantic by calling `to_dict()` of wind_direction
        if self.wind_direction:
            _dict['windDirection'] = self.wind_direction.to_dict()
        # override the default output from pydantic by calling `to_dict()` of wind_speed
        if self.wind_speed:
            _dict['windSpeed'] = self.wind_speed.to_dict()
        # override the default output from pydantic by calling `to_dict()` of wind_gust
        if self.wind_gust:
            _dict['windGust'] = self.wind_gust.to_dict()
        # override the default output from pydantic by calling `to_dict()` of barometric_pressure
        if self.barometric_pressure:
            _dict['barometricPressure'] = self.barometric_pressure.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sea_level_pressure
        if self.sea_level_pressure:
            _dict['seaLevelPressure'] = self.sea_level_pressure.to_dict()
        # override the default output from pydantic by calling `to_dict()` of visibility
        if self.visibility:
            _dict['visibility'] = self.visibility.to_dict()
        # override the default output from pydantic by calling `to_dict()` of max_temperature_last24_hours
        if self.max_temperature_last24_hours:
            _dict['maxTemperatureLast24Hours'] = self.max_temperature_last24_hours.to_dict()
        # override the default output from pydantic by calling `to_dict()` of min_temperature_last24_hours
        if self.min_temperature_last24_hours:
            _dict['minTemperatureLast24Hours'] = self.min_temperature_last24_hours.to_dict()
        # override the default output from pydantic by calling `to_dict()` of precipitation_last_hour
        if self.precipitation_last_hour:
            _dict['precipitationLastHour'] = self.precipitation_last_hour.to_dict()
        # override the default output from pydantic by calling `to_dict()` of precipitation_last3_hours
        if self.precipitation_last3_hours:
            _dict['precipitationLast3Hours'] = self.precipitation_last3_hours.to_dict()
        # override the default output from pydantic by calling `to_dict()` of precipitation_last6_hours
        if self.precipitation_last6_hours:
            _dict['precipitationLast6Hours'] = self.precipitation_last6_hours.to_dict()
        # override the default output from pydantic by calling `to_dict()` of relative_humidity
        if self.relative_humidity:
            _dict['relativeHumidity'] = self.relative_humidity.to_dict()
        # override the default output from pydantic by calling `to_dict()` of wind_chill
        if self.wind_chill:
            _dict['windChill'] = self.wind_chill.to_dict()
        # override the default output from pydantic by calling `to_dict()` of heat_index
        if self.heat_index:
            _dict['heatIndex'] = self.heat_index.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in cloud_layers (list)
        _items = []
        if self.cloud_layers:
            for _item in self.cloud_layers:
                if _item:
                    _items.append(_item.to_dict())
            _dict['cloudLayers'] = _items
        # set to None if geometry (nullable) is None
        # and model_fields_set contains the field
        if self.geometry is None and "geometry" in self.model_fields_set:
            _dict['geometry'] = None

        # set to None if icon (nullable) is None
        # and model_fields_set contains the field
        if self.icon is None and "icon" in self.model_fields_set:
            _dict['icon'] = None

        # set to None if cloud_layers (nullable) is None
        # and model_fields_set contains the field
        if self.cloud_layers is None and "cloud_layers" in self.model_fields_set:
            _dict['cloudLayers'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Observation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "@context": JsonLdContext.from_dict(obj["@context"]) if obj.get("@context") is not None else None,
            "geometry": obj.get("geometry"),
            "@id": obj.get("@id"),
            "@type": obj.get("@type"),
            "elevation": QuantitativeValue.from_dict(obj["elevation"]) if obj.get("elevation") is not None else None,
            "station": obj.get("station"),
            "timestamp": obj.get("timestamp"),
            "rawMessage": obj.get("rawMessage"),
            "textDescription": obj.get("textDescription"),
            "icon": obj.get("icon"),
            "presentWeather": [MetarPhenomenon.from_dict(_item) for _item in obj["presentWeather"]] if obj.get("presentWeather") is not None else None,
            "temperature": QuantitativeValue.from_dict(obj["temperature"]) if obj.get("temperature") is not None else None,
            "dewpoint": QuantitativeValue.from_dict(obj["dewpoint"]) if obj.get("dewpoint") is not None else None,
            "windDirection": QuantitativeValue.from_dict(obj["windDirection"]) if obj.get("windDirection") is not None else None,
            "windSpeed": QuantitativeValue.from_dict(obj["windSpeed"]) if obj.get("windSpeed") is not None else None,
            "windGust": QuantitativeValue.from_dict(obj["windGust"]) if obj.get("windGust") is not None else None,
            "barometricPressure": QuantitativeValue.from_dict(obj["barometricPressure"]) if obj.get("barometricPressure") is not None else None,
            "seaLevelPressure": QuantitativeValue.from_dict(obj["seaLevelPressure"]) if obj.get("seaLevelPressure") is not None else None,
            "visibility": QuantitativeValue.from_dict(obj["visibility"]) if obj.get("visibility") is not None else None,
            "maxTemperatureLast24Hours": QuantitativeValue.from_dict(obj["maxTemperatureLast24Hours"]) if obj.get("maxTemperatureLast24Hours") is not None else None,
            "minTemperatureLast24Hours": QuantitativeValue.from_dict(obj["minTemperatureLast24Hours"]) if obj.get("minTemperatureLast24Hours") is not None else None,
            "precipitationLastHour": QuantitativeValue.from_dict(obj["precipitationLastHour"]) if obj.get("precipitationLastHour") is not None else None,
            "precipitationLast3Hours": QuantitativeValue.from_dict(obj["precipitationLast3Hours"]) if obj.get("precipitationLast3Hours") is not None else None,
            "precipitationLast6Hours": QuantitativeValue.from_dict(obj["precipitationLast6Hours"]) if obj.get("precipitationLast6Hours") is not None else None,
            "relativeHumidity": QuantitativeValue.from_dict(obj["relativeHumidity"]) if obj.get("relativeHumidity") is not None else None,
            "windChill": QuantitativeValue.from_dict(obj["windChill"]) if obj.get("windChill") is not None else None,
            "heatIndex": QuantitativeValue.from_dict(obj["heatIndex"]) if obj.get("heatIndex") is not None else None,
            "cloudLayers": [ObservationCloudLayersInner.from_dict(_item) for _item in obj["cloudLayers"]] if obj.get("cloudLayers") is not None else None
        })
        return _obj


