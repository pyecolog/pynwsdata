


from collections.abc import Callable
from datetime import date, datetime
from typing import TYPE_CHECKING, Annotated, Any, Optional, Union, TypeAlias
import warnings

from pynwsdata.api_object import ApiField
from pynwsdata.models.alert_certainty import AlertCertainty
from pynwsdata.models.alert_collection_geo_json import AlertCollectionGeoJson
from pynwsdata.models.alert_geo_json import AlertGeoJson
from pynwsdata.models.alert_severity import AlertSeverity
from pynwsdata.models.alert_urgency import AlertUrgency
from pynwsdata.models.alerts_active_count200_response import AlertsActiveCount200Response
from pynwsdata.models.alerts_types200_response import AlertsTypes200Response
from pynwsdata.models.area_code import AreaCode
from pynwsdata.models.center_weather_advisory_collection_geo_json import CenterWeatherAdvisoryCollectionGeoJson
from pynwsdata.models.center_weather_advisory_geo_json import CenterWeatherAdvisoryGeoJson
from pynwsdata.models.glossary200_response import Glossary200Response
from pynwsdata.models.gridpoint_forecast_geo_json import GridpointForecastGeoJson
from pynwsdata.models.gridpoint_forecast_units import GridpointForecastUnits
from pynwsdata.models.gridpoint_geo_json import GridpointGeoJson
from pynwsdata.models.marine_region_code import MarineRegionCode
from pynwsdata.models.nws_center_weather_service_unit_id import NWSCenterWeatherServiceUnitId
from pynwsdata.models.nws_forecast_office_id import NWSForecastOfficeId
from pynwsdata.models.nws_zone_type import NWSZoneType
from pynwsdata.models.observation_collection_geo_json import ObservationCollectionGeoJson
from pynwsdata.models.observation_geo_json import ObservationGeoJson
from pynwsdata.models.observation_station_collection_geo_json import ObservationStationCollectionGeoJson
from pynwsdata.models.observation_station_geo_json import ObservationStationGeoJson
from pynwsdata.models.office import Office
from pynwsdata.models.office_headline import OfficeHeadline
from pynwsdata.models.office_headline_collection import OfficeHeadlineCollection
from pynwsdata.models.point_geo_json import PointGeoJson
from pynwsdata.models.problem_detail import ProblemDetail
from pynwsdata.models.region_code import RegionCode
from pynwsdata.models.sigmet_collection_geo_json import SigmetCollectionGeoJson
from pynwsdata.models.sigmet_geo_json import SigmetGeoJson
from pynwsdata.models.text_product import TextProduct
from pynwsdata.models.text_product_collection import TextProductCollection
from pynwsdata.models.text_product_location_collection import TextProductLocationCollection
from pynwsdata.models.text_product_type_collection import TextProductTypeCollection
from pynwsdata.models.zone_collection_geo_json import ZoneCollectionGeoJson
from pynwsdata.models.zone_forecast_geo_json import ZoneForecastGeoJson
from pynwsdata.models.zone_geo_json import ZoneGeoJson

from pynwsdata.api_client import ApiClient, RequestSerialized

RESPONSE_ERROR: TypeAlias = Exception

FORECAST_FLAGS_INTERIM: list[str] = ["forecast_wind_speed_qv", "forecast_temperature_qv"]

def format_coord(coord: float) -> str:
    # format the coord to 4 decimal points,
    # the removing trailing zeros
    return "{0:.4f}".format(coord).rstrip("0.")

class DefaultApi:
    """This class was auto generated by OpenAPI Generator"""


    if TYPE_CHECKING:
        api_client: ApiClient

    def __init__(self, api_client: Optional[ApiClient]=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    def alerts_active(
        self,
        status: Optional[list[str]] = None,
        message_type: Optional[list[str]] = None,
        event: Optional[list[str]] = None,
        code: Optional[list[str]] = None,
        area: Optional[list[AreaCode]] = None,
        point: Optional[str] = None,
        region: Optional[list[MarineRegionCode]] = None,
        region_type: Optional[str] = None,
        zone: Optional[list[str]] = None,
        urgency: Optional[list[AlertUrgency]] = None,
        severity: Optional[list[AlertSeverity]] = None,
        certainty: Optional[list[AlertCertainty]] = None,
        limit: Optional[int] = None,  # max: 500
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> AlertCollectionGeoJson:
        """alerts_active

        Returns all currently active alerts

        :param status: Status (actual, exercise, system, test, draft)
        :type status: list[str]
        :param message_type: Message type (alert, update, cancel)
        :type message_type: list[str]
        :param event: Event name
        :type event: list[str]
        :param code: Event code
        :type code: list[str]
        :param area: State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
        :type area: list[AreaCode]
        :param point: Point (latitude,longitude)
        This parameter is incompatible with the following parameters: area, region, region_type, zone
        :type point: str
        :param region: Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
        :type region: list[MarineRegionCode]
        :param region_type: Region type (land or marine)
        This parameter is incompatible with the following parameters: area, point, region, zone
        :type region_type: str
        :param zone: Zone ID (forecast or county)
        This parameter is incompatible with the following parameters: area, point, region, region_type
        :type zone: list[str]
        :param urgency: Urgency (immediate, expected, future, past, unknown)
        :type urgency: list[AlertUrgency]
        :param severity: Severity (extreme, severe, moderate, minor, unknown)
        :type severity: list[AlertSeverity]
        :param certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :type certainty: list[AlertCertainty]
        :param limit: Limit
        :type limit: int
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._alerts_active_serialize(
            status=status,
            message_type=message_type,
            event=event,
            code=code,
            area=area,
            point=point,
            region=region,
            region_type=region_type,
            zone=zone,
            urgency=urgency,
            severity=severity,
            certainty=certainty,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: AlertCollectionGeoJson,
            301: RESPONSE_ERROR,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _alerts_active_serialize(
        self,
        status,
        message_type,
        event,
        code,
        area,
        point,
        region,
        region_type,
        zone,
        urgency,
        severity,
        certainty,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'status': 'csv',
            'message_type': 'csv',
            'event': 'csv',
            'code': 'csv',
            'area': 'csv',
            'region': 'csv',
            'zone': 'csv',
            'urgency': 'csv',
            'severity': 'csv',
            'certainty': 'csv',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if status is not None:

            _query_params.append(('status', status))

        if message_type is not None:

            _query_params.append(('message_type', message_type))

        if event is not None:

            _query_params.append(('event', event))

        if code is not None:

            _query_params.append(('code', code))

        if area is not None:

            _query_params.append(('area', area))

        if point is not None:

            _query_params.append(('point', point))

        if region is not None:

            _query_params.append(('region', region))

        if region_type is not None:

            _query_params.append(('region_type', region_type))

        if zone is not None:

            _query_params.append(('zone', zone))

        if urgency is not None:

            _query_params.append(('urgency', urgency))

        if severity is not None:

            _query_params.append(('severity', severity))

        if certainty is not None:

            _query_params.append(('certainty', certainty))

        if limit is not None:

            _query_params.append(('limit', limit))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/alerts/active',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def alerts_active_area(
        self,
        area: Any,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> AlertCollectionGeoJson:
        """alerts_active_area

        Returns active alerts for the given area (state or marine area)

        :param area: State/area ID (required)
        :type area: AreaCode
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._alerts_active_area_serialize(
            area=area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: AlertCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _alerts_active_area_serialize(
        self,
        area,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if area is not None:
            _path_params['area'] = area
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/atom+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/alerts/active/area/{area}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def alerts_active_count(
        self,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> AlertsActiveCount200Response:
        """alerts_active_count

        Returns info on the number of active alerts

        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._alerts_active_count_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: AlertsActiveCount200Response,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _alerts_active_count_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/alerts/active/count',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def alerts_active_region(
        self,
        region: MarineRegionCode,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> AlertCollectionGeoJson:
        """alerts_active_region

        Returns active alerts for the given marine region

        :param region: Marine region ID (required)
        :type region: MarineRegionCode
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._alerts_active_region_serialize(
            region=region,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: AlertCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _alerts_active_region_serialize(
        self,
        region,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if region is not None:
            _path_params['region'] = region.value
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/atom+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/alerts/active/region/{region}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def alerts_active_zone(
        self,
        zone_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> AlertCollectionGeoJson:
        """alerts_active_zone

        Returns active alerts for the given NWS public zone or county

        :param zone_id: NWS public zone/county identifier (required)
        :type zone_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._alerts_active_zone_serialize(
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: AlertCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _alerts_active_zone_serialize(
        self,
        zone_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if zone_id is not None:
            _path_params['zoneId'] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/atom+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/alerts/active/zone/{zoneId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def alerts_query(
        self,
        active: Optional[bool] = None,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        status: Optional[list[str]] = None,
        message_type: Optional[list[str]] = None,
        event: Optional[list[str]] = None,
        code: Optional[list[str]] = None,
        area: Optional[list[AreaCode]] = None,
        point: Optional[str] = None,
        region: Optional[list[MarineRegionCode]] = None,
        region_type: Optional[str] = None,
        zone: Optional[list[str]] = None,
        urgency: Optional[list[AlertUrgency]] = None,
        severity: Optional[list[AlertSeverity]] = None,
        certainty: Optional[list[AlertCertainty]] = None,
        limit: Optional[int] = None,
        cursor: Optional[str] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> AlertCollectionGeoJson:
        """alerts_query

        Returns all alerts

        :param active: list only active alerts (use /alerts/active endpoints instead)
        :type active: bool
        :param start: Start time
        :type start: datetime
        :param end: End time
        :type end: datetime
        :param status: Status (actual, exercise, system, test, draft)
        :type status: list[str]
        :param message_type: Message type (alert, update, cancel)
        :type message_type: list[str]
        :param event: Event name
        :type event: list[str]
        :param code: Event code
        :type code: list[str]
        :param area: State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
        :type area: list[AreaCode]
        :param point: Point (latitude,longitude)
        This parameter is incompatible with the following parameters: area, region, region_type, zone
        :type point: str
        :param region: Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
        :type region: list[MarineRegionCode]
        :param region_type: Region type (land or marine)
        This parameter is incompatible with the following parameters: area, point, region, zone
        :type region_type: str
        :param zone: Zone ID (forecast or county)
        This parameter is incompatible with the following parameters: area, point, region, region_type
        :type zone: list[str]
        :param urgency: Urgency (immediate, expected, future, past, unknown)
        :type urgency: list[AlertUrgency]
        :param severity: Severity (extreme, severe, moderate, minor, unknown)
        :type severity: list[AlertSeverity]
        :param certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :type certainty: list[AlertCertainty]
        :param limit: Limit
        :type limit: int
        :param cursor: Pagination cursor
        :type cursor: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._alerts_query_serialize(
            active=active,
            start=start,
            end=end,
            status=status,
            message_type=message_type,
            event=event,
            code=code,
            area=area,
            point=point,
            region=region,
            region_type=region_type,
            zone=zone,
            urgency=urgency,
            severity=severity,
            certainty=certainty,
            limit=limit,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: AlertCollectionGeoJson,
            301: RESPONSE_ERROR,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _alerts_query_serialize(
        self,
        active,
        start,
        end,
        status,
        message_type,
        event,
        code,
        area,
        point,
        region,
        region_type,
        zone,
        urgency,
        severity,
        certainty,
        limit,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'status': 'csv',
            'message_type': 'csv',
            'event': 'csv',
            'code': 'csv',
            'area': 'csv',
            'region': 'csv',
            'zone': 'csv',
            'urgency': 'csv',
            'severity': 'csv',
            'certainty': 'csv',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if active is not None:

            _query_params.append(('active', active))

        if start is not None:
            if isinstance(start, datetime):
                _query_params.append(
                    (
                        'start',
                        start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start', start))

        if end is not None:
            if isinstance(end, datetime):
                _query_params.append(
                    (
                        'end',
                        end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end', end))

        if status is not None:

            _query_params.append(('status', status))

        if message_type is not None:

            _query_params.append(('message_type', message_type))

        if event is not None:

            _query_params.append(('event', event))

        if code is not None:

            _query_params.append(('code', code))

        if area is not None:

            _query_params.append(('area', area))

        if point is not None:

            _query_params.append(('point', point))

        if region is not None:

            _query_params.append(('region', region))

        if region_type is not None:

            _query_params.append(('region_type', region_type))

        if zone is not None:

            _query_params.append(('zone', zone))

        if urgency is not None:

            _query_params.append(('urgency', urgency))

        if severity is not None:

            _query_params.append(('severity', severity))

        if certainty is not None:

            _query_params.append(('certainty', certainty))

        if limit is not None:

            _query_params.append(('limit', limit))

        if cursor is not None:

            _query_params.append(('cursor', cursor))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/atom+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/alerts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def alerts_single(
        self,
        id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> AlertGeoJson:
        """alerts_single

        Returns a specific alert

        :param id: Alert identifier (required)
        :type id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._alerts_single_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: AlertGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _alerts_single_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/cap+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/alerts/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def alerts_types(
        self,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> AlertsTypes200Response:
        """alerts_types

        Returns a list of alert types

        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._alerts_types_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: AlertsTypes200Response,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _alerts_types_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/alerts/types',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def cwa(
        self,
        cwsu_id: NWSCenterWeatherServiceUnitId,
        var_date: date,
        sequence: int,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> CenterWeatherAdvisoryGeoJson:
        """cwa

        Returns a list of Center Weather Advisories from a CWSU

        :param cwsu_id: NWS CWSU ID (required)
        :type cwsu_id: NWSCenterWeatherServiceUnitId
        :param var_date: Date (YYYY-MM-DD format) (required)
        :type var_date: date
        :param sequence: Sequence number (required)
        :type sequence: int
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._cwa_serialize(
            cwsu_id=cwsu_id,
            var_date=var_date,
            sequence=sequence,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: CenterWeatherAdvisoryGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _cwa_serialize(
        self,
        cwsu_id,
        var_date,
        sequence,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if cwsu_id is not None:
            _path_params['cwsuId'] = cwsu_id.value
        if var_date is not None:
            _path_params['date'] = var_date
        if sequence is not None:
            _path_params['sequence'] = sequence
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/vnd.noaa.uswx+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/aviation/cwsus/{cwsuId}/cwas/{date}/{sequence}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def cwas(
        self,
        cwsu_id: NWSCenterWeatherServiceUnitId,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> CenterWeatherAdvisoryCollectionGeoJson:
        """cwas

        Returns a list of Center Weather Advisories from a CWSU

        :param cwsu_id: NWS CWSU ID (required)
        :type cwsu_id: NWSCenterWeatherServiceUnitId
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._cwas_serialize(
            cwsu_id=cwsu_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: CenterWeatherAdvisoryCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _cwas_serialize(
        self,
        cwsu_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if cwsu_id is not None:
            _path_params['cwsuId'] = cwsu_id.value
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/aviation/cwsus/{cwsuId}/cwas',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def cwsu(
        self,
        cwsu_id: NWSCenterWeatherServiceUnitId,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> Office:
        """cwsu

        Returns metadata about a Center Weather Service Unit

        :param cwsu_id: NWS CWSU ID (required)
        :type cwsu_id: NWSCenterWeatherServiceUnitId
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._cwsu_serialize(
            cwsu_id=cwsu_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: Office,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _cwsu_serialize(
        self,
        cwsu_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if cwsu_id is not None:
            _path_params['cwsuId'] = cwsu_id.value
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/aviation/cwsus/{cwsuId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def glossary(
        self,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> Glossary200Response:
        """glossary

        Returns glossary terms

        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._glossary_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: Glossary200Response,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _glossary_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/glossary',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def gridpoint(
        self,
        wfo: NWSForecastOfficeId,
        x: int,
        y: int,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> GridpointGeoJson:
        """gridpoint

        Returns raw numerical forecast data for a 2.5km grid area

        :param wfo: Forecast office ID (required)
        :type wfo: NWSForecastOfficeId
        :param x: Forecast grid X coordinate (required)
        :type x: int
        :param y: Forecast grid Y coordinate (required)
        :type y: int
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._gridpoint_serialize(
            wfo=wfo,
            x=x,
            y=y,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: GridpointGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _gridpoint_serialize(
        self,
        wfo,
        x,
        y,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wfo is not None:
            _path_params['wfo'] = wfo.value
        if x is not None:
            _path_params['x'] = x
        if y is not None:
            _path_params['y'] = y
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/gridpoints/{wfo}/{x},{y}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def gridpoint_forecast(
        self,
        wfo: NWSForecastOfficeId,
        x: int,
        y: int,
        feature_flags: Optional[list[str]] = FORECAST_FLAGS_INTERIM,
        units: Optional[GridpointForecastUnits] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> GridpointForecastGeoJson:
        """gridpoint_forecast

        Returns a textual forecast for a 2.5km grid area

        :param wfo: Forecast office ID (required)
        :type wfo: NWSForecastOfficeId
        :param x: Forecast grid X coordinate (required)
        :type x: int
        :param y: Forecast grid Y coordinate (required)
        :type y: int
        :param feature_flags: Enable future and experimental features (see documentation for more info):
        * forecast_temperature_qv: Represent temperature as QuantitativeValue
        * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
        :type feature_flags: list[str]
        :param units: Use US customary or SI (metric) units in textual output
        :type units: GridpointForecastUnits
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._gridpoint_forecast_serialize(
            wfo=wfo,
            x=x,
            y=y,
            feature_flags=feature_flags,
            units=units,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: GridpointForecastGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _gridpoint_forecast_serialize(
        self,
        wfo,
        x,
        y,
        feature_flags,
        units,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'Feature-Flags': 'csv',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wfo is not None:
            _path_params['wfo'] = wfo.value
        if x is not None:
            _path_params['x'] = x
        if y is not None:
            _path_params['y'] = y
        # process the query parameters
        if units is not None:

            _query_params.append(('units', units.value))

        # process the header parameters
        if feature_flags is not None:
            _header_params['Feature-Flags'] = feature_flags
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/vnd.noaa.dwml+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/gridpoints/{wfo}/{x},{y}/forecast',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def gridpoint_forecast_hourly(
        self,
        wfo: NWSForecastOfficeId,
        x: int,
        y: int,
        feature_flags: Optional[list[str]] = None,
        units: Optional[GridpointForecastUnits] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> GridpointForecastGeoJson:
        """gridpoint_forecast_hourly

        Returns a textual hourly forecast for a 2.5km grid area

        :param wfo: Forecast office ID (required)
        :type wfo: NWSForecastOfficeId
        :param x: Forecast grid X coordinate (required)
        :type x: int
        :param y: Forecast grid Y coordinate (required)
        :type y: int
        :param feature_flags: Enable future and experimental features (see documentation for more info):
        * forecast_temperature_qv: Represent temperature as QuantitativeValue
        * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
        :type feature_flags: list[str]
        :param units: Use US customary or SI (metric) units in textual output
        :type units: GridpointForecastUnits
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._gridpoint_forecast_hourly_serialize(
            wfo=wfo,
            x=x,
            y=y,
            feature_flags=feature_flags,
            units=units,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: GridpointForecastGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _gridpoint_forecast_hourly_serialize(
        self,
        wfo,
        x,
        y,
        feature_flags,
        units,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'Feature-Flags': 'csv',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wfo is not None:
            _path_params['wfo'] = wfo.value
        if x is not None:
            _path_params['x'] = x
        if y is not None:
            _path_params['y'] = y
        # process the query parameters
        if units is not None:

            _query_params.append(('units', units.value))

        # process the header parameters
        if feature_flags is not None:
            _header_params['Feature-Flags'] = feature_flags
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/vnd.noaa.dwml+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/gridpoints/{wfo}/{x},{y}/forecast/hourly',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def gridpoint_stations(
        self,
        wfo: NWSForecastOfficeId,
        x: int,
        y: int,
        limit: Optional[int] = None,
        cursor: Optional[str] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ObservationStationCollectionGeoJson:
        """gridpoint_stations

        Returns a list of observation stations usable for a given 2.5km grid area

        :param wfo: Forecast office ID (required)
        :type wfo: NWSForecastOfficeId
        :param x: Forecast grid X coordinate (required)
        :type x: int
        :param y: Forecast grid Y coordinate (required)
        :type y: int
        :param limit: Limit
        :type limit: int
        :param cursor: Pagination cursor
        :type cursor: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._gridpoint_stations_serialize(
            wfo=wfo,
            x=x,
            y=y,
            limit=limit,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ObservationStationCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _gridpoint_stations_serialize(
        self,
        wfo,
        x,
        y,
        limit,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wfo is not None:
            _path_params['wfo'] = wfo.value
        if x is not None:
            _path_params['x'] = x
        if y is not None:
            _path_params['y'] = y
        # process the query parameters
        if limit is not None:

            _query_params.append(('limit', limit))

        if cursor is not None:

            _query_params.append(('cursor', cursor))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/gridpoints/{wfo}/{x},{y}/stations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def icons(
        self,
        set: str,
        time_of_day: str,
        first: str,
        size: Optional[Any] = None,
        fontsize: Optional[int] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> bytearray:
        """(Deprecated) icons

        Returns a forecast icon. Icon services in API are deprecated.

        :param set: . (required)
        :type set: str
        :param time_of_day: . (required)
        :type time_of_day: str
        :param first: . (required)
        :type first: str
        :param size: Font size
        :type size: IconsSizeParameter
        :param fontsize: Font size
        :type fontsize: int
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        warnings.warn(
            "GET /icons/{set}/{timeOfDay}/{first} is deprecated.", DeprecationWarning)

        _param = self._icons_serialize(
            set=set,
            time_of_day=time_of_day,
            first=first,
            size=size,
            fontsize=fontsize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: bytearray,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _icons_serialize(
        self,
        set,
        time_of_day,
        first,
        size,
        fontsize,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if set is not None:
            _path_params['set'] = set
        if time_of_day is not None:
            _path_params['timeOfDay'] = time_of_day
        if first is not None:
            _path_params['first'] = first
        # process the query parameters
        if size is not None:

            _query_params.append(('size', size))

        if fontsize is not None:

            _query_params.append(('fontsize', fontsize))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'image/png',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/icons/{set}/{timeOfDay}/{first}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def icons_dual_condition(
        self,
        set: str,
        time_of_day: str,
        first: str,
        second: str,
        size: Optional[Any] = None,
        fontsize: Optional[int] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> bytearray:
        """(Deprecated) icons_dual_condition

        Returns a forecast icon. Icon services in API are deprecated.

        :param set: . (required)
        :type set: str
        :param time_of_day: . (required)
        :type time_of_day: str
        :param first: . (required)
        :type first: str
        :param second: . (required)
        :type second: str
        :param size: Font size
        :type size: IconsSizeParameter
        :param fontsize: Font size
        :type fontsize: int
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        warnings.warn(
            "GET /icons/{set}/{timeOfDay}/{first}/{second} is deprecated.", DeprecationWarning)

        _param = self._icons_dual_condition_serialize(
            set=set,
            time_of_day=time_of_day,
            first=first,
            second=second,
            size=size,
            fontsize=fontsize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: bytearray,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _icons_dual_condition_serialize(
        self,
        set,
        time_of_day,
        first,
        second,
        size,
        fontsize,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if set is not None:
            _path_params['set'] = set
        if time_of_day is not None:
            _path_params['timeOfDay'] = time_of_day
        if first is not None:
            _path_params['first'] = first
        if second is not None:
            _path_params['second'] = second
        # process the query parameters
        if size is not None:

            _query_params.append(('size', size))

        if fontsize is not None:

            _query_params.append(('fontsize', fontsize))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'image/png',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/icons/{set}/{timeOfDay}/{first}/{second}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def location_products(
        self,
        location_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> TextProductTypeCollection:
        """location_products

        Returns a list of valid text product types for a given issuance location

        :param location_id: . (required)
        :type location_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._location_products_serialize(
            location_id=location_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: TextProductTypeCollection,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _location_products_serialize(
        self,
        location_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if location_id is not None:
            _path_params['locationId'] = location_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/products/locations/{locationId}/types',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def obs_station(
        self,
        station_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ObservationStationGeoJson:
        """obs_station

        Returns metadata about a given observation station

        :param station_id: Observation station ID (required)
        :type station_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._obs_station_serialize(
            station_id=station_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ObservationStationGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _obs_station_serialize(
        self,
        station_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if station_id is not None:
            _path_params['stationId'] = station_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/stations/{stationId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def obs_stations(
        self,
        id: Optional[list[str]] = None,
        state: Optional[list[AreaCode]] = None,
        limit: Optional[int] = None,
        cursor: Optional[str] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ObservationStationCollectionGeoJson:
        """obs_stations

        Returns a list of observation stations.

        :param id: Filter by observation station ID
        :type id: list[str]
        :param state: Filter by state/marine area code
        :type state: list[AreaCode]
        :param limit: Limit
        :type limit: int
        :param cursor: Pagination cursor
        :type cursor: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._obs_stations_serialize(
            id=id,
            state=state,
            limit=limit,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ObservationStationCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _obs_stations_serialize(
        self,
        id,
        state,
        limit,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'id': 'csv',
            'state': 'csv',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:

            _query_params.append(('id', id))

        if state is not None:

            _query_params.append(('state', state))

        if limit is not None:

            _query_params.append(('limit', limit))

        if cursor is not None:

            _query_params.append(('cursor', cursor))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/stations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def office(
        self,
        office_id: Any,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> Office:
        """office

        Returns metadata about a NWS forecast office

        :param office_id: NWS office ID (required)
        :type office_id: NWSOfficeId
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._office_serialize(
            office_id=office_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: Office,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _office_serialize(
        self,
        office_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if office_id is not None:
            _path_params['officeId'] = office_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offices/{officeId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def office_headline(
        self,
        office_id: Any,
        headline_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> OfficeHeadline:
        """office_headline

        Returns a specific news headline for a given NWS office

        :param office_id: NWS office ID (required)
        :type office_id: NWSOfficeId
        :param headline_id: Headline record ID (required)
        :type headline_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._office_headline_serialize(
            office_id=office_id,
            headline_id=headline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: OfficeHeadline,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _office_headline_serialize(
        self,
        office_id,
        headline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if office_id is not None:
            _path_params['officeId'] = office_id
        if headline_id is not None:
            _path_params['headlineId'] = headline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offices/{officeId}/headlines/{headlineId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def office_headlines(
        self,
        office_id: Any,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> OfficeHeadlineCollection:
        """office_headlines

        Returns a list of news headlines for a given NWS office

        :param office_id: NWS office ID (required)
        :type office_id: NWSOfficeId
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._office_headlines_serialize(
            office_id=office_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: OfficeHeadlineCollection,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _office_headlines_serialize(
        self,
        office_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if office_id is not None:
            _path_params['officeId'] = office_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offices/{officeId}/headlines',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def point(
        self,
        point: Union[tuple[float, float], str],
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> PointGeoJson:
        """point

        Returns metadata about a given latitude/longitude point

        :param point: Point (required). tuple of latitude, longitude
                      or string "<lat>,<long>". Note that the precision
                      for string values is limtied to 4 decimal digits.
                      If the point value is provided as a tuple, this
                      precision will be applied automatically.
        :type point: Union[tuple[float, float], str]

        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        if isinstance(point, (tuple, list)):
            point = ",".join(map(format_coord, point))

        _param = self._point_serialize(
            point=point,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: PointGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _point_serialize(
        self,
        point,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if point is not None:
            _path_params['point'] = point
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/points/{point}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def point_stations(
        self,
        point: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ProblemDetail:
        """(Deprecated) point_stations

        Returns a list of observation stations for a given point

        :param point: Point (latitude, longitude) (required)
        :type point: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        warnings.warn(
            "GET /points/{point}/stations is deprecated.", DeprecationWarning)

        _param = self._point_stations_serialize(
            point=point,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            301: RESPONSE_ERROR,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _point_stations_serialize(
        self,
        point,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if point is not None:
            _path_params['point'] = point
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/points/{point}/stations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def product(
        self,
        product_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> TextProduct:
        """product

        Returns a specific text product

        :param product_id: . (required)
        :type product_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._product_serialize(
            product_id=product_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: TextProduct,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _product_serialize(
        self,
        product_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if product_id is not None:
            _path_params['productId'] = product_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/products/{productId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def product_locations(
        self,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> TextProductLocationCollection:
        """product_locations

        Returns a list of valid text product issuance locations

        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._product_locations_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: TextProductLocationCollection,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _product_locations_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/products/locations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def product_types(
        self,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> TextProductTypeCollection:
        """product_types

        Returns a list of valid text product types and codes

        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._product_types_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: TextProductTypeCollection,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _product_types_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/products/types',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def products_query(
        self,
        location: Annotated[Optional[list[str]],
                            ApiField(description="""Location id""")] = None,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        office: Optional[list[str]] = None,
        wmoid: Optional[list[str]] = None,
        type: Optional[list[str]] = None,
        limit: Optional[int] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> TextProductCollection:
        """products_query

        Returns a list of text products

        :param location: Location id
        :type location: list[str]
        :param start: Start time
        :type start: datetime
        :param end: End time
        :type end: datetime
        :param office: Issuing office
        :type office: list[str]
        :param wmoid: WMO id code
        :type wmoid: list[str]
        :param type: Product code
        :type type: list[str]
        :param limit: Limit
        :type limit: int
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._products_query_serialize(
            location=location,
            start=start,
            end=end,
            office=office,
            wmoid=wmoid,
            type=type,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: TextProductCollection,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _products_query_serialize(
        self,
        location,
        start,
        end,
        office,
        wmoid,
        type,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'location': 'csv',
            'office': 'csv',
            'wmoid': 'csv',
            'type': 'csv',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if location is not None:

            _query_params.append(('location', location))

        if start is not None:
            if isinstance(start, datetime):
                _query_params.append(
                    (
                        'start',
                        start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start', start))

        if end is not None:
            if isinstance(end, datetime):
                _query_params.append(
                    (
                        'end',
                        end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end', end))

        if office is not None:

            _query_params.append(('office', office))

        if wmoid is not None:

            _query_params.append(('wmoid', wmoid))

        if type is not None:

            _query_params.append(('type', type))

        if limit is not None:

            _query_params.append(('limit', limit))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/products',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def products_type(
        self,
        type_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> TextProductCollection:
        """products_type

        Returns a list of text products of a given type

        :param type_id: . (required)
        :type type_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._products_type_serialize(
            type_id=type_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: TextProductCollection,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _products_type_serialize(
        self,
        type_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type_id is not None:
            _path_params['typeId'] = type_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/products/types/{typeId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def products_type_location(
        self,
        type_id: str,
        location_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> TextProductCollection:
        """products_type_location

        Returns a list of text products of a given type for a given issuance location

        :param type_id: . (required)
        :type type_id: str
        :param location_id: . (required)
        :type location_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._products_type_location_serialize(
            type_id=type_id,
            location_id=location_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: TextProductCollection,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _products_type_location_serialize(
        self,
        type_id,
        location_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type_id is not None:
            _path_params['typeId'] = type_id
        if location_id is not None:
            _path_params['locationId'] = location_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/products/types/{typeId}/locations/{locationId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def products_type_locations(
        self,
        type_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> TextProductLocationCollection:
        """products_type_locations

        Returns a list of valid text product issuance locations for a given product type

        :param type_id: . (required)
        :type type_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._products_type_locations_serialize(
            type_id=type_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: TextProductLocationCollection,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _products_type_locations_serialize(
        self,
        type_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type_id is not None:
            _path_params['typeId'] = type_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/products/types/{typeId}/locations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def radar_profiler(
        self,
        station_id: str,
        time: Optional[Any] = None,
        interval: Optional[str] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> object:
        """radar_profiler

        Returns metadata about a given radar wind profiler

        :param station_id: Profiler station ID (required)
        :type station_id: str
        :param time: Time interval
        :type time: ISO8601Interval
        :param interval: Averaging interval
        :type interval: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._radar_profiler_serialize(
            station_id=station_id,
            time=time,
            interval=interval,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: object,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _radar_profiler_serialize(
        self,
        station_id,
        time,
        interval,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if station_id is not None:
            _path_params['stationId'] = station_id
        # process the query parameters
        if time is not None:

            _query_params.append(('time', time))

        if interval is not None:

            _query_params.append(('interval', interval))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/radar/profilers/{stationId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def radar_queue(
        self,
        host: str,
        limit: Optional[int] = None,
        arrived: Optional[Any] = None,
        created: Optional[Any] = None,
        published: Optional[Any] = None,
        station: Optional[str] = None,
        type: Optional[str] = None,
        feed: Optional[str] = None,
        resolution: Optional[int] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> object:
        """radar_queue

        Returns metadata about a given radar queue

        :param host: LDM host (required)
        :type host: str
        :param limit: Record limit
        :type limit: int
        :param arrived: Range for arrival time
        :type arrived: ISO8601Interval
        :param created: Range for creation time
        :type created: ISO8601Interval
        :param published: Range for publish time
        :type published: ISO8601Interval
        :param station: Station identifier
        :type station: str
        :param type: Record type
        :type type: str
        :param feed: Originating product feed
        :type feed: str
        :param resolution: Resolution version
        :type resolution: int
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._radar_queue_serialize(
            host=host,
            limit=limit,
            arrived=arrived,
            created=created,
            published=published,
            station=station,
            type=type,
            feed=feed,
            resolution=resolution,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: object,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _radar_queue_serialize(
        self,
        host,
        limit,
        arrived,
        created,
        published,
        station,
        type,
        feed,
        resolution,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if host is not None:
            _path_params['host'] = host
        # process the query parameters
        if limit is not None:

            _query_params.append(('limit', limit))

        if arrived is not None:

            _query_params.append(('arrived', arrived))

        if created is not None:

            _query_params.append(('created', created))

        if published is not None:

            _query_params.append(('published', published))

        if station is not None:

            _query_params.append(('station', station))

        if type is not None:

            _query_params.append(('type', type))

        if feed is not None:

            _query_params.append(('feed', feed))

        if resolution is not None:

            _query_params.append(('resolution', resolution))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/radar/queues/{host}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def radar_server(
        self,
        id: str,
        reporting_host: Optional[str] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> object:
        """radar_server

        Returns metadata about a given radar server

        :param id: Server ID (required)
        :type id: str
        :param reporting_host: Show records from specific reporting host
        :type reporting_host: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._radar_server_serialize(
            id=id,
            reporting_host=reporting_host,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: object,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _radar_server_serialize(
        self,
        id,
        reporting_host,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if reporting_host is not None:

            _query_params.append(('reportingHost', reporting_host))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/radar/servers/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def radar_servers(
        self,
        reporting_host: Optional[str] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> object:
        """radar_servers

        Returns a list of radar servers

        :param reporting_host: Show records from specific reporting host
        :type reporting_host: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._radar_servers_serialize(
            reporting_host=reporting_host,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: object,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _radar_servers_serialize(
        self,
        reporting_host,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if reporting_host is not None:

            _query_params.append(('reportingHost', reporting_host))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/radar/servers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def radar_station(
        self,
        station_id: str,
        reporting_host: Optional[str] = None,
        host: Optional[str] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> object:
        """radar_station

        Returns metadata about a given radar station

        :param station_id: Radar station ID (required)
        :type station_id: str
        :param reporting_host: Show RDA and latency info from specific reporting host
        :type reporting_host: str
        :param host: Show latency info from specific LDM host
        :type host: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._radar_station_serialize(
            station_id=station_id,
            reporting_host=reporting_host,
            host=host,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: object,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _radar_station_serialize(
        self,
        station_id,
        reporting_host,
        host,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if station_id is not None:
            _path_params['stationId'] = station_id
        # process the query parameters
        if reporting_host is not None:

            _query_params.append(('reportingHost', reporting_host))

        if host is not None:

            _query_params.append(('host', host))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/radar/stations/{stationId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def radar_station_alarms(
        self,
        station_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> object:
        """radar_station_alarms

        Returns metadata about a given radar station alarms

        :param station_id: Radar station ID (required)
        :type station_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._radar_station_alarms_serialize(
            station_id=station_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: object,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _radar_station_alarms_serialize(
        self,
        station_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if station_id is not None:
            _path_params['stationId'] = station_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/radar/stations/{stationId}/alarms',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def radar_stations(
        self,
        station_type: Optional[list[str]] = None,
        reporting_host: Optional[str] = None,
        host: Optional[str] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> object:
        """radar_stations

        Returns a list of radar stations

        :param station_type: Limit results to a specific station type or types
        :type station_type: list[str]
        :param reporting_host: Show RDA and latency info from specific reporting host
        :type reporting_host: str
        :param host: Show latency info from specific LDM host
        :type host: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._radar_stations_serialize(
            station_type=station_type,
            reporting_host=reporting_host,
            host=host,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: object,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _radar_stations_serialize(
        self,
        station_type,
        reporting_host,
        host,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'stationType': 'csv',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if station_type is not None:

            _query_params.append(('stationType', station_type))

        if reporting_host is not None:

            _query_params.append(('reportingHost', reporting_host))

        if host is not None:

            _query_params.append(('host', host))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/radar/stations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def satellite_thumbnails(
        self,
        area: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> bytearray:
        """(Deprecated) satellite_thumbnails

        Returns a thumbnail image for a satellite region. Image services in API are deprecated.

        :param area: . (required)
        :type area: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        warnings.warn(
            "GET /thumbnails/satellite/{area} is deprecated.", DeprecationWarning)

        _param = self._satellite_thumbnails_serialize(
            area=area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: bytearray,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _satellite_thumbnails_serialize(
        self,
        area,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if area is not None:
            _path_params['area'] = area
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'image/jpeg',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/thumbnails/satellite/{area}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def sigmet(
        self,
        atsu: str,
        var_date: date,
        time: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> SigmetGeoJson:
        """sigmet

        Returns a specific SIGMET/AIRMET

        :param atsu: ATSU identifier (required)
        :type atsu: str
        :param var_date: Date (YYYY-MM-DD format) (required)
        :type var_date: date
        :param time: Time (HHMM format). This time is always specified in UTC (Zulu) time. (required)
        :type time: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._sigmet_serialize(
            atsu=atsu,
            var_date=var_date,
            time=time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: SigmetGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _sigmet_serialize(
        self,
        atsu,
        var_date,
        time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if atsu is not None:
            _path_params['atsu'] = atsu
        if var_date is not None:
            _path_params['date'] = var_date
        if time is not None:
            _path_params['time'] = time
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/vnd.noaa.uswx+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/aviation/sigmets/{atsu}/{date}/{time}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def sigmet_query(
        self,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        var_date: Optional[date] = None,
        atsu: Optional[str] = None,
        sequence: Optional[str] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> SigmetCollectionGeoJson:
        """sigmet_query

        Returns a list of SIGMET/AIRMETs

        :param start: Start time
        :type start: datetime
        :param end: End time
        :type end: datetime
        :param var_date: Date (YYYY-MM-DD format)
        :type var_date: date
        :param atsu: ATSU identifier
        :type atsu: str
        :param sequence: SIGMET sequence number
        :type sequence: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._sigmet_query_serialize(
            start=start,
            end=end,
            var_date=var_date,
            atsu=atsu,
            sequence=sequence,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: SigmetCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _sigmet_query_serialize(
        self,
        start,
        end,
        var_date,
        atsu,
        sequence,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start is not None:
            if isinstance(start, datetime):
                _query_params.append(
                    (
                        'start',
                        start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start', start))

        if end is not None:
            if isinstance(end, datetime):
                _query_params.append(
                    (
                        'end',
                        end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end', end))

        if var_date is not None:
            if isinstance(var_date, date):
                _query_params.append(
                    (
                        'date',
                        var_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date', var_date))

        if atsu is not None:

            _query_params.append(('atsu', atsu))

        if sequence is not None:

            _query_params.append(('sequence', sequence))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/aviation/sigmets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def sigmets_by_atsu(
        self,
        atsu: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> SigmetCollectionGeoJson:
        """sigmets_by_atsu

        Returns a list of SIGMET/AIRMETs for the specified ATSU

        :param atsu: ATSU identifier (required)
        :type atsu: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._sigmets_by_atsu_serialize(
            atsu=atsu,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: SigmetCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _sigmets_by_atsu_serialize(
        self,
        atsu,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if atsu is not None:
            _path_params['atsu'] = atsu
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/aviation/sigmets/{atsu}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def sigmets_by_atsuby_date(
        self,
        atsu: str,
        var_date: date,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> SigmetCollectionGeoJson:
        """sigmets_by_atsuby_date

        Returns a list of SIGMET/AIRMETs for the specified ATSU for the specified date

        :param atsu: ATSU identifier (required)
        :type atsu: str
        :param var_date: Date (YYYY-MM-DD format) (required)
        :type var_date: date
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._sigmets_by_atsuby_date_serialize(
            atsu=atsu,
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: SigmetCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _sigmets_by_atsuby_date_serialize(
        self,
        atsu,
        var_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if atsu is not None:
            _path_params['atsu'] = atsu
        if var_date is not None:
            _path_params['date'] = var_date
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/aviation/sigmets/{atsu}/{date}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def station_observation_latest(
        self,
        station_id: str,
        require_qc: Annotated[Optional[bool],
                              ApiField(description="""Require QC""")] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ObservationGeoJson:
        """station_observation_latest

        Returns the latest observation for a station

        :param station_id: Observation station ID (required)
        :type station_id: str
        :param require_qc: Require QC
        :type require_qc: bool
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._station_observation_latest_serialize(
            station_id=station_id,
            require_qc=require_qc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ObservationGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _station_observation_latest_serialize(
        self,
        station_id,
        require_qc,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if station_id is not None:
            _path_params['stationId'] = station_id
        # process the query parameters
        if require_qc is not None:

            _query_params.append(('require_qc', require_qc))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/vnd.noaa.uswx+xml',
                    'application/vnd.noaa.obs+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/stations/{stationId}/observations/latest',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def station_observation_list(
        self,
        station_id: str,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        limit: Optional[int] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ObservationCollectionGeoJson:
        """station_observation_list

        Returns a list of observations for a given station

        :param station_id: Observation station ID (required)
        :type station_id: str
        :param start: Start time
        :type start: datetime
        :param end: End time
        :type end: datetime
        :param limit: Limit
        :type limit: int
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._station_observation_list_serialize(
            station_id=station_id,
            start=start,
            end=end,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ObservationCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _station_observation_list_serialize(
        self,
        station_id,
        start,
        end,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if station_id is not None:
            _path_params['stationId'] = station_id
        # process the query parameters
        if start is not None:
            if isinstance(start, datetime):
                _query_params.append(
                    (
                        'start',
                        start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start', start))

        if end is not None:
            if isinstance(end, datetime):
                _query_params.append(
                    (
                        'end',
                        end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end', end))

        if limit is not None:

            _query_params.append(('limit', limit))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/stations/{stationId}/observations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def station_observation_time(
        self,
        station_id: str,
        time: datetime,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ObservationGeoJson:
        """station_observation_time

        Returns a single observation.

        :param station_id: Observation station ID (required)
        :type station_id: str
        :param time: Timestamp of requested observation (required)
        :type time: datetime
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._station_observation_time_serialize(
            station_id=station_id,
            time=time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ObservationGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _station_observation_time_serialize(
        self,
        station_id,
        time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if station_id is not None:
            _path_params['stationId'] = station_id
        if time is not None:
            _path_params['time'] = time
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/vnd.noaa.uswx+xml',
                    'application/vnd.noaa.obs+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/stations/{stationId}/observations/{time}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def taf(
        self,
        station_id: str,
        var_date: date,
        time: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> object:
        """taf

        Returns a single Terminal Aerodrome Forecast.

        :param station_id: Observation station ID (required)
        :type station_id: str
        :param var_date: Date (YYYY-MM-DD format) (required)
        :type var_date: date
        :param time: Time (HHMM format). This time is always specified in UTC (Zulu) time. (required)
        :type time: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._taf_serialize(
            station_id=station_id,
            var_date=var_date,
            time=time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: object,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _taf_serialize(
        self,
        station_id,
        var_date,
        time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if station_id is not None:
            _path_params['stationId'] = station_id
        if var_date is not None:
            _path_params['date'] = var_date
        if time is not None:
            _path_params['time'] = time
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/vnd.wmo.iwxxm+xml',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/stations/{stationId}/tafs/{date}/{time}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def tafs(
        self,
        station_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> object:
        """tafs

        Returns Terminal Aerodrome Forecasts for the specified airport station.

        :param station_id: Observation station ID (required)
        :type station_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._tafs_serialize(
            station_id=station_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: object,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _tafs_serialize(
        self,
        station_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if station_id is not None:
            _path_params['stationId'] = station_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/stations/{stationId}/tafs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def zone(
        self,
        type: NWSZoneType,
        zone_id: str,
        effective: Optional[datetime] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ZoneGeoJson:
        """zone

        Returns metadata about a given zone

        :param type: Zone type (required)
        :type type: NWSZoneType
        :param zone_id: NWS public zone/county identifier (required)
        :type zone_id: str
        :param effective: Effective date/time
        :type effective: datetime
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._zone_serialize(
            type=type,
            zone_id=zone_id,
            effective=effective,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ZoneGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _zone_serialize(
        self,
        type,
        zone_id,
        effective,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type is not None:
            _path_params['type'] = type.value
        if zone_id is not None:
            _path_params['zoneId'] = zone_id
        # process the query parameters
        if effective is not None:
            if isinstance(effective, datetime):
                _query_params.append(
                    (
                        'effective',
                        effective.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('effective', effective))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/zones/{type}/{zoneId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def zone_forecast(
        self,
        type: str,
        zone_id: str,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ZoneForecastGeoJson:
        """zone_forecast

        Returns the current zone forecast for a given zone

        :param type: Zone type (required)
        :type type: str
        :param zone_id: NWS public zone/county identifier (required)
        :type zone_id: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._zone_forecast_serialize(
            type=type,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ZoneForecastGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _zone_forecast_serialize(
        self,
        type,
        zone_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type is not None:
            _path_params['type'] = type
        if zone_id is not None:
            _path_params['zoneId'] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/zones/{type}/{zoneId}/forecast',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def zone_list(
        self,
        id: Optional[list[str]] = None,
        area: Optional[list[AreaCode]] = None,
        region: Annotated[Optional[list[RegionCode]],
                          ApiField(description="""Region code""")] = None,
        type: Annotated[Optional[list[NWSZoneType]],
                        ApiField(description="""Zone type""")] = None,
        point: Optional[str] = None,
        include_geometry: Optional[bool] = None,
        limit: Optional[int] = None,
        effective: Optional[datetime] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ZoneCollectionGeoJson:
        """zone_list

        Returns a list of zones

        :param id: Zone ID (forecast or county)
        :type id: list[str]
        :param area: State/marine area code
        :type area: list[AreaCode]
        :param region: Region code
        :type region: list[RegionCode]
        :param type: Zone type
        :type type: list[NWSZoneType]
        :param point: Point (latitude,longitude)
        :type point: str
        :param include_geometry: Include geometry in results (true/false)
        :type include_geometry: bool
        :param limit: Limit
        :type limit: int
        :param effective: Effective date/time
        :type effective: datetime
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._zone_list_serialize(
            id=id,
            area=area,
            region=region,
            type=type,
            point=point,
            include_geometry=include_geometry,
            limit=limit,
            effective=effective,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ZoneCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _zone_list_serialize(
        self,
        id,
        area,
        region,
        type,
        point,
        include_geometry,
        limit,
        effective,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'id': 'csv',
            'area': 'csv',
            'region': 'csv',
            'type': 'csv',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:

            _query_params.append(('id', id))

        if area is not None:

            _query_params.append(('area', area))

        if region is not None:

            _query_params.append(('region', region))

        if type is not None:

            _query_params.append(('type', type))

        if point is not None:

            _query_params.append(('point', point))

        if include_geometry is not None:

            _query_params.append(('include_geometry', include_geometry))

        if limit is not None:

            _query_params.append(('limit', limit))

        if effective is not None:
            if isinstance(effective, datetime):
                _query_params.append(
                    (
                        'effective',
                        effective.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('effective', effective))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/zones',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def zone_list_type(
        self,
        type: NWSZoneType,
        id: Optional[list[str]] = None,
        area: Optional[list[AreaCode]] = None,
        region: Annotated[Optional[list[RegionCode]],
                          ApiField(description="""Region code""")] = None,
        type2: Annotated[Optional[list[NWSZoneType]],
                         ApiField(description="""Zone type""")] = None,
        point: Optional[str] = None,
        include_geometry: Optional[bool] = None,
        limit: Optional[int] = None,
        effective: Optional[datetime] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ZoneCollectionGeoJson:
        """zone_list_type

        Returns a list of zones of a given type

        :param type: Zone type (required)
        :type type: NWSZoneType
        :param id: Zone ID (forecast or county)
        :type id: list[str]
        :param area: State/marine area code
        :type area: list[AreaCode]
        :param region: Region code
        :type region: list[RegionCode]
        :param type2: Zone type
        :type type2: list[NWSZoneType]
        :param point: Point (latitude,longitude)
        :type point: str
        :param include_geometry: Include geometry in results (true/false)
        :type include_geometry: bool
        :param limit: Limit
        :type limit: int
        :param effective: Effective date/time
        :type effective: datetime
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._zone_list_type_serialize(
            type=type,
            id=id,
            area=area,
            region=region,
            type2=type2,
            point=point,
            include_geometry=include_geometry,
            limit=limit,
            effective=effective,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ZoneCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _zone_list_type_serialize(
        self,
        type,
        id,
        area,
        region,
        type2,
        point,
        include_geometry,
        limit,
        effective,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'id': 'csv',
            'area': 'csv',
            'region': 'csv',
            'type': 'csv',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if type is not None:
            _path_params['type'] = type.value
        # process the query parameters
        if id is not None:

            _query_params.append(('id', id))

        if area is not None:

            _query_params.append(('area', area))

        if region is not None:

            _query_params.append(('region', region))

        if type2 is not None:

            _query_params.append(('type', type2))

        if point is not None:

            _query_params.append(('point', point))

        if include_geometry is not None:

            _query_params.append(('include_geometry', include_geometry))

        if limit is not None:

            _query_params.append(('limit', limit))

        if effective is not None:
            if isinstance(effective, datetime):
                _query_params.append(
                    (
                        'effective',
                        effective.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('effective', effective))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/zones/{type}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def zone_obs(
        self,
        zone_id: str,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        limit: Optional[int] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ObservationCollectionGeoJson:
        """zone_obs

        Returns a list of observations for a given zone

        :param zone_id: NWS public zone/county identifier (required)
        :type zone_id: str
        :param start: Start date/time
        :type start: datetime
        :param end: End date/time
        :type end: datetime
        :param limit: Limit
        :type limit: int
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._zone_obs_serialize(
            zone_id=zone_id,
            start=start,
            end=end,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ObservationCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _zone_obs_serialize(
        self,
        zone_id,
        start,
        end,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if zone_id is not None:
            _path_params['zoneId'] = zone_id
        # process the query parameters
        if start is not None:
            if isinstance(start, datetime):
                _query_params.append(
                    (
                        'start',
                        start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start', start))

        if end is not None:
            if isinstance(end, datetime):
                _query_params.append(
                    (
                        'end',
                        end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end', end))

        if limit is not None:

            _query_params.append(('limit', limit))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/zones/forecast/{zoneId}/observations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )

    def zone_stations(
        self,
        zone_id: str,
        limit: Optional[int] = None,
        cursor: Optional[str] = None,
        _request_auth: Optional[dict[str, Any]] = None,
        _content_type: Optional[str] = None,
        _headers: Optional[dict[str, Any]] = None,
        _host_index: int = 0,
    ) -> ObservationStationCollectionGeoJson:
        """zone_stations

        Returns a list of observation stations for a given zone

        :param zone_id: NWS public zone/county identifier (required)
        :type zone_id: str
        :param limit: Limit
        :type limit: int
        :param cursor: Pagination cursor
        :type cursor: str
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._zone_stations_serialize(
            zone_id=zone_id,
            limit=limit,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, Optional[str]] = {
            200: ObservationStationCollectionGeoJson,
        }
        response_data = self.api_client.call_api(
            *_param,
        )
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def _zone_stations_serialize(
        self,
        zone_id,
        limit,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, Optional[str]] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if zone_id is not None:
            _path_params['zoneId'] = zone_id
        # process the query parameters
        if limit is not None:

            _query_params.append(('limit', limit))

        if cursor is not None:

            _query_params.append(('cursor', cursor))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/geo+json',
                    'application/ld+json',
                    'application/problem+json'
                ]
            )

        # authentication setting
        _auth_settings: list[str] = [
            'userAgent'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/zones/forecast/{zoneId}/stations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )
